import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Create{{SingularName}}Dto } from './dto/create-{{singularName}}.dto';
import { Update{{SingularName}}Dto } from './dto/update-{{singularName}}.dto';
import { {{SingularName}}, {{SingularName}}Document } from './schema/{{singularName}}.schema';

@Injectable()
export class {{ModuleName}}Service {
  constructor(
    @InjectModel({{SingularName}}.name) 
    private readonly {{camelSingularName}}Model: Model<{{SingularName}}Document>,
  ) {}
  
  async create(create{{SingularName}}Dto: Create{{SingularName}}Dto): Promise<{{SingularName}}> {
    try {
      const created{{SingularName}} = new this.{{camelSingularName}}Model(create{{SingularName}}Dto);
      return await created{{SingularName}}.save();
    } catch (error) {
      throw new BadRequestException(`Failed to create {{singularName}}: ${error.message}`);
    }
  }
  
  async findAll(): Promise<{{SingularName}}[]> {
    return this.{{camelSingularName}}Model.find().lean().exec();
  }

  async findOne(id: string): Promise<{{SingularName}}> {
    if (!id.match(/^[0-9a-fA-F]{24}$/)) {
      throw new BadRequestException('Invalid ID format');
    }

    const {{camelSingularName}} = await this.{{camelSingularName}}Model.findById(id).exec();
    if (!{{camelSingularName}}) {
      throw new NotFoundException(`{{SingularName}} with ID ${id} not found`);
    }
    return {{camelSingularName}};
  }

  async findByName(name: string): Promise<{{SingularName}}[]> {
    return this.{{camelSingularName}}Model
      .find({ name: { $regex: name, $options: 'i' } })
      .exec();
  }

  async update(id: string, update{{SingularName}}Dto: Update{{SingularName}}Dto): Promise<{{SingularName}}> {
    if (!id.match(/^[0-9a-fA-F]{24}$/)) {
      throw new BadRequestException('Invalid ID format');
    }

    const updated{{SingularName}} = await this.{{camelSingularName}}Model
      .findByIdAndUpdate(id, update{{SingularName}}Dto, {
        new: true,
        runValidators: true,
      })
      .exec();

    if (!updated{{SingularName}}) {
      throw new NotFoundException(`{{SingularName}} with ID ${id} not found`);
    }

    return updated{{SingularName}};
  }

  async remove(id: string): Promise<{ message: string; deletedId: string }> {
    if (!id.match(/^[0-9a-fA-F]{24}$/)) {
      throw new BadRequestException('Invalid ID format');
    }

    const deleted{{SingularName}} = await this.{{camelSingularName}}Model
      .findByIdAndDelete(id)
      .exec();

    if (!deleted{{SingularName}}) {
      throw new NotFoundException(`{{SingularName}} with ID ${id} not found`);
    }

    return {
      message: `{{SingularName}} with ID ${id} has been successfully deleted`,
      deletedId: id,
    };
  }

  async removeMany(ids: string[]): Promise<{ message: string; deletedCount: number }> {
    const validIds = ids.filter(id => id.match(/^[0-9a-fA-F]{24}$/));
    
    if (validIds.length !== ids.length) {
      throw new BadRequestException('Some IDs have invalid format');
    }

    const result = await this.{{camelSingularName}}Model
      .deleteMany({ _id: { $in: validIds } })
      .exec();

    return {
      message: `Successfully deleted ${result.deletedCount} {{singularName}}(s)`,
      deletedCount: result.deletedCount,
    };
  }

  async count(search?: string): Promise<number> {
    let query = {};
    if (search) {
      query = {
        $or: [
          { name: { $regex: search, $options: 'i' } },
          { description: { $regex: search, $options: 'i' } },
        ],
      };
    }
    return this.{{camelSingularName}}Model.countDocuments(query).exec();
  }

  async exists(id: string): Promise<boolean> {
    if (!id.match(/^[0-9a-fA-F]{24}$/)) {
      return false;
    }
    const count = await this.{{camelSingularName}}Model.countDocuments({ _id: id }).exec();
    return count > 0;
  }
}